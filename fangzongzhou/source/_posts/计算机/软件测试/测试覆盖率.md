---
title: 测试覆盖率
categories:
  - 测试
tags:
  - 测试
date: 2020-12-16 10:14:33
---

测试覆盖率主要分为两大类，一类是面向项目的需求覆盖率，另一类是更偏向技术的代码覆盖率

## 需求覆盖率

需求覆盖率是指测试对需求的覆盖程度，通常的做法是将每一条分解后的软件需求和对应的测试建立一对多的映射关系，最终目标是保证测试可以覆盖每个需求，以保证软件产品的质量

采用ALM，Doors和TestLink 等需求管理工具来建立需求和测试的对应关系，并以此计算测试覆盖率

## 代码覆盖率

代码覆盖率是指，至少被执行了一次的条目数占整个条目数的百分比

常用的三种代码覆盖率指标

- 行覆盖率又称为语句覆盖率，指已经被执行到的语句占总可执行语句(不包含类似C++的头文件声明、代码注释、空行等等)的百分比。这是最常用也是要求最低的覆盖率指标。 实际项目中通常会结合判定覆盖率或者条件覆盖率一起使用
- 判定覆盖又称分支覆盖，用以度量程序中每一个判定的分支是否都被测试到了，即代码中每个判断的取真分支和取假分支是否各被覆盖至少各一次。比如，对于if(a>0 && b>0)，就要求覆盖“a>0 && b>0”为TURE和FALSE各一次
- 条件覆盖是指，判定中的每个条件的可能取值至少满足一次，度量判定中的每个条件的结果TRUE和FALSE是否都被测试到了。比如，对于if(a>0 && b>0)，就要 求“a>0”取TRUE和FALSE各一次，同时要求“b>0”取TRUE和FALSE各一次。
<!--more-->

### 代码覆盖率的价值

> 统计代码覆盖率的根本目的是找出潜在的遗漏测试用例，并有针对性的进行补充，同时还可以识别出代码中那些由于需求变更等原因造成的不可达的废弃代码

在软件企业中，只有单元测试阶段对代码覆盖率有较高的要求。因为从技术实现上讲，单元测试可以最大化地利用打桩技术来提高覆盖率。而你如果想在集成测试或者 是GUI测试阶段将代码覆盖率提高到一定量级，那你所要付出的代价是巨大的，而且在很多情况下根本就实现不了

### 代码覆盖率的局限性

代码覆盖率的计算是基于现有代码的，并不能发现那些“未考虑 某些输入”以及“未处理某些情况”形成的缺陷

代码覆盖率反映的仅仅是已有代码的哪些逻辑被执行过了，哪些逻辑还没有被执行过。以此为依据，你可以补充测试用例，可以去测试那些还没有覆盖到的执行路径。但也是 仅此而已，对于那些压根还没有代码实现的部分，基于代码覆盖率的统计指标就无能为力了

高的代码覆盖率不一定能保证软件的质量，但是低的代码覆盖率一定不能能保证软件的质量

### 代码覆盖率工具

Java: Jacoco

![统计代码覆盖率的不同注入实现技术](https://s3.ax1x.com/2020/12/16/rQbvjO.png)

实现代码覆盖率的统计，最基本的方法就是注入(Instrumentation)。简单地说，注入就是在被测代码中自动插入用于覆盖率统计的探针(Probe)代码，并保证插入的探针代码不会给原代码带来任何影响

对于Java代码来讲，根据注入目标的不同，可以分为源代码(Source Code)注入和字节码(Byte Code)注入两大类。基于JVM本身特性以及执行效率的原因，目前主流的工具 基本都是使用字节码注入，注入的具体实现采用ASM技术

ASM是一个Java字节码操纵框架，能被用来动态生成类或者增强既有类的功能，可以直接产生 class 文件，也可以在类被加载入JVM之前动态改变类行为。 根据注入发生的时间点，字节码注入又可以分为两大模式:On-The-Fly注入模式和Ofine注入模式。

**On-The-Fly注入模式**: 无需修改源代码，也无需提前进行字节码插桩。它适用于支持Java Agent的运行环境,优点是，可以在系统不停机的情况下，实时收集代码覆盖率信息。缺点是运行环境必须允许使用Java Agent

实现On-The-Fly模式，主要有两种技术方案:

1. 开发自定义的类装载器(Class Loader)实现类装载策略，每次类加载前，需要在class文件中插入探针，早期的Emma就是使用这种方案实现的探针插入;
2. 借助Java Agent，利用执行在main()方法之前的拦截器方法premain()来插入探针，实际使用过程中需要在JVM的启动参数中添加“-javaagent”并指定用于实时字节码注入的
代理程序，这样代理程序在装载每个class文件前，先判断是否已经插入了探针，如果没有则需要将探针插入class文件中，目前主流的JaCoCo就是使用了这个方式

**Ofine注入模式**:无需修改源代码，但是需要在测试开始之前先对文件进行插桩，并事先生成插过桩的class文件。它适用于不支持Java Agent的运行环境，以及无法使用自定义类装载 器的场景,优点是，JVM启动时不再需要使用Java Agent额外开启代理，缺点是无法实时获取代码覆盖率信息，只能在系统停机时下获取。

C/C++，JavaScript等语言的代码覆盖率工具，比如GCC Coverage、JSCoverage和Istanbul
